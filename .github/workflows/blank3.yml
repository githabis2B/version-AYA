name: Blank3
on:
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    timeout-minutes: 360
    permissions:
      contents: read

    steps:
      - name: Checkout Script
        uses: actions/checkout@v4

      - name: Maximize Build Space
        uses: easimon/maximize-build-space@master
        with:
          root-reserve-mb: 8192
          temp-reserve-mb: 2048
          remove-dotnet: 'true'
          remove-android: 'true'
          remove-haskell: 'true'
          swap-size-mb: 16384

      - name: Install Build Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y bc build-essential flex bison libssl-dev libelf-dev clang lld llvm python3-pip unzip p7zip-full

      - name: Download and Extract Source
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "正在下载源码..."
          gh release download kernel --repo ${{ github.repository }} --pattern 'Kernel.tar.gz' --clobber
          
          echo "正在解压源码..."
          mkdir -p kernel_source
          if ls *.zip 1> /dev/null 2>&1; then
            unzip -q *.zip -d kernel_source/
          elif ls *.tar.gz 1> /dev/null 2>&1; then
            tar -zxf *.tar.gz -C kernel_source/
          fi
          
          if [ -d "kernel_source/kernel_source" ]; then
            mv kernel_source/kernel_source/* kernel_source/
          fi

      - name: Download and Setup Official Toolchain
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # 1. 确定工作根目录
          PROJECT_ROOT=$(find $GITHUB_WORKSPACE/kernel_source -name "kernel_platform" -printf '%h\n' | head -n 1)
          cd "$PROJECT_ROOT"

          echo "正在下载工具链分卷..."
          gh release download S24_Tools --repo ${{ github.repository }} --pattern 'toolchain.tar.tar.*' --clobber

          echo "正在合并并提取分卷 (7z)..."
          # 7z 会直接从 .001 提取出里面的压缩包
          7z x toolchain.tar.tar.001 -y
          
          # 【关键调试步骤】列出当前文件，看看 7z 到底解压出了什么
          echo "检查当前目录下文件："
          ls -lh
          
          # 2. 物理定位解压出来的压缩包 (自动处理命名不一致)
          GZ_FILE=$(ls *.tar.gz 2>/dev/null | head -n 1)
          if [ -z "$GZ_FILE" ]; then
            echo "错误：未发现 .tar.gz 文件，尝试查找 .tar"
            TAR_FILE=$(ls *.tar 2>/dev/null | head -n 1)
          else
            echo "发现压缩包: $GZ_FILE，正在解压缩为 .tar..."
            # 使用 gunzip 保持文件名一致性，这样更节省空间且稳定
            gunzip -f "$GZ_FILE"
            TAR_FILE=$(ls *.tar 2>/dev/null | head -n 1)
          fi

          if [ -z "$TAR_FILE" ]; then
            echo "错误：无法定位到任何 .tar 文件！"
            ls -R
            exit 1
          fi

          echo "最终解压 $TAR_FILE 到 prebuilts..."
          mkdir -p kernel_platform/prebuilts
          # 执行最终解压
          tar -xf "$TAR_FILE" -C kernel_platform/prebuilts/ --strip-components=1

          echo "清理临时大文件..."
          rm -f toolchain.tar.tar.*
          rm -f *.tar
          
          echo "工具链就位！验证路径："
          ls -F kernel_platform/prebuilts/ | head -n 10


      - name: Setup KernelSU and Security Patches
        run: |
          COMMON_PATH=$(find $GITHUB_WORKSPACE/kernel_source -name "common" -type d | grep "kernel_platform/common" | head -n 1)
          cd "$COMMON_PATH"

          # 1. 集成 KernelSU
          curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -

          # 2. 修改 Defconfig 
          DEFCONFIG="arch/arm64/configs/gki_defconfig"
          ./scripts/config --file $DEFCONFIG \
            -d UH \
            -d FIVE \
            -d PROCA \
            -d PROCA_S_OS \
            -d PROCA_CERTIFICATES_DB \
            -d SECURITY_DEFEX \
            -d KNOX_NCM \
            -d KNOX_KNOX_NCM \
            -d SECURITY_DSMS \
            -d SECURITY_KUMIHO \
            -d MODULE_SIG 
          
          # 开启KernelSU
          echo "CONFIG_KSU=y" >> $DEFCONFIG
          # Littlenine 提到的其他干扰项 源码里没有 手动加上
          echo "CONFIG_INTEGRITY=n" >> $DEFCONFIG
          # 重要：禁用 TRIM_UNUSED_KSYMS (确保 KSU 能找到符号)
          echo "CONFIG_TRIM_UNUSED_KSYMS=n" >> $DEFCONFIG
          

          # 物理删除 ABI 保护文件
          rm -f android/abi_gki_protected_exports_*


      - name: Build Kernel
        run: |
          PROJECT_ROOT=$(find $GITHUB_WORKSPACE/kernel_source -name "kernel_platform" -printf '%h\n' | head -n 1)
          cd "$PROJECT_ROOT"

          # 修复官方工具链中的 Python 软链接
          PY3_DIR="kernel_platform/prebuilts/build-tools/path/linux-x86"
          mkdir -p "$PY3_DIR"
          ln -sf $(which python3) "$PY3_DIR/python3"

         
          
          # 将解压后的内置工具链加入 PATH
          # 优先使用 prebuilts 里的 bazel 和工具
          export PATH=$PWD/kernel_platform/prebuilts/bazel/linux-x86_64:$PATH
          export PATH=$PWD/kernel_platform/prebuilts/build-tools/path/linux-x86:$PATH
          
          # 提权
          chmod -R +x kernel_platform/prebuilts/
          chmod +x ./kernel_platform/build/android/prepare_vendor.sh
          chmod +x ./build_kernel_GKI.sh

          # 资源限制防止 OOM
          export BAZEL_RAM=6144
          export BAZEL_JOBS=2

          #修复变量
          #1. target config
          BUILD_TARGET=e1q_chn_openx
          export MODEL=$(echo $BUILD_TARGET | cut -d'_' -f1)
          export PROJECT_NAME=${MODEL}
          export REGION=$(echo $BUILD_TARGET | cut -d'_' -f2)
          export CARRIER=$(echo $BUILD_TARGET | cut -d'_' -f3)
          export TARGET_BUILD_VARIANT=user
          
          #2. sm8650 common config
          CHIPSET_NAME=pineapple

          export ANDROID_BUILD_TOP=$(pwd)
          export TARGET_PRODUCT=gki
          export TARGET_BOARD_PLATFORM=gki
          export ANDROID_PRODUCT_OUT=${ANDROID_BUILD_TOP}/out/target/product/${MODEL}
          export OUT_DIR=${ANDROID_BUILD_TOP}/out/msm-${CHIPSET_NAME}-${CHIPSET_NAME}-${TARGET_PRODUCT}
          
          export KBUILD_EXT_MODULES="\
                    ../vendor/qcom/opensource/display-drivers/msm \
                    ../vendor/qcom/opensource/camera-kernel \
                    ../vendor/qcom/opensource/audio-kernel \
                    ../vendor/qcom/opensource/dsp-kernel \
                    "

          export  KBUILD_DISPLAY_EXTRA_SYMBOLS="\
                    ../vendor/qcom/opensource/mmrm-driver/Module.symvers \
                    ../vendor/qcom/opensource/mm-drivers/sync_fence/Module.symvers \
                    ../vendor/qcom/opensource/mm-drivers/msm_ext_display/Module.symvers \
                    ../vendor/qcom/opensource/mm-drivers/hw_fence/Module.symvers \
                    ../vendor/qcom/opensource/securemsm-kernel/Module.symvers \
                    "




          # 这将找到 kernel_platform 所在的父目录绝对路径
          REAL_ROOT=$(find "$GITHUB_WORKSPACE" -name "kernel_platform" -type d | head -n 1)
          PROJECT_ROOT=$(dirname "$REAL_ROOT")

          # 检查路径是否有效，防止 cd 到根目录 /
          if [ -z "$PROJECT_ROOT" ] || [ "$PROJECT_ROOT" = "/" ]; then
              echo "错误：无法正确定位 kernel_source 路径！"
              exit 1
          fi

          cd "$PROJECT_ROOT"
          echo "当前工作目录: $(pwd)"

          # 2. 设置必要变量
          export MODEL="e1q"
          export ANDROID_BUILD_TOP=$(pwd)
          # ... 其他 export 变量保持不变 ...

          # 3. 预创建目录（此时变量已确保不为空）
          mkdir -p "${ANDROID_BUILD_TOP}/out/target/product/${MODEL}"

          # 4. 进入平台目录并动态寻找 build.sh
          cd kernel_platform
          # 动态寻找 build.sh 的位置（兼容不同版本的目录结构）
          BUILD_SH_PATH=$(find . -name "build.sh" | head -n 1)

          if [ -f "$BUILD_SH_PATH" ]; then
              echo "找到构建脚本: $BUILD_SH_PATH"
              chmod +x "$BUILD_SH_PATH"
    
              # 5. 执行构建 (带上环境变量确保生效)
              TARGET_BOARD_PLATFORM=gki VENDOR_NAME=sec SKIP_MRPROPER=1 \
              "$BUILD_SH_PATH" 2>&1 | tee -a ../build.log
          else
              echo "错误：找不到 build.sh！"
              ls -R
              exit 1
          fi

        



      - name: Upload Kernel Output
        uses: actions/upload-artifact@v4
        with:
          name: S24-Kernel-$(date +%Y%m%d)
          path: |
            kernel_source/out/**/boot/Image
            kernel_source/out/**/dist/Image
            kernel_source/out/**/*.ko
